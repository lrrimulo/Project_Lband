"""
This is the main program of the L-band project. 
"""

import numpy as np
import pyhdust.phc as phc
import pyhdust.spectools as spt
import pyhdust.lrr as lrr
import matplotlib.pyplot as plt
import emcee
import corner
import glob as glob
import read_data as read_data
import read_everything as read_everything


#############################
### This is the zeroth part of the analysis: reading everything (or almost!).
### We will read the observables calculated from the SED's (which were calculated 
### in another program, because this task takes time) and we will
### also read the available observational data on the Be stars.
### With this data, it is possible to make the analysis intended by this 
### program.

#############################
### Full name of the file containing the observables generated from 
### HDUST's output. 
### (This file was generated by 'observables_OldBeAtlas.py'.)
fileobservables = "observables_BeAtlas.txt" 

### Reading that file.
g0 = open(fileobservables,'r')
g0linhas = g0.readlines()
g0.close()
### Splitting the contents of each line (to be used below).
for ilinha in range(0,len(g0linhas)):
    g0linhas[ilinha] = g0linhas[ilinha].split()

### Declaring the lists that will receive the different observables. 
### This is a preliminary step, before making the arrays for each observable.

### The lists of observables of four model parameters
TEMP_read = []
SOURCE_read = []

### The lists of observables of the four model parameters + cosi
SNRATIOS_read = []
###    
UBVRI_read = []
JHK_read = []
HALPHA_SOAR_read = []
WISE_filters_read = []
ALPHA_WISE_read = []
IRAC_filters_read = []
### 
LINE_HALPHA_read = []
LINE_HBETA_read = []
LINE_HGAMMA_read = []    
###
LINE_BRALPHA_read = []   
LINE_BRGAMMA_read = []    
### 
LINE_PFGAMMA_read = []    
###
LINE_HUMPHREY14_read = []
LINE_HUMPHREY15_read = []
LINE_HUMPHREY16_read = []
LINE_HUMPHREY18_read = []
LINE_HUMPHREY19_read = []
LINE_HUMPHREY20_read = []
LINE_HUMPHREY21_read = []
LINE_HUMPHREY22_read = []
LINE_HUMPHREY23_read = []
LINE_HUMPHREY24_read = []
LINE_HUMPHREY25_read = []
###
BL_FLUX_read = []    
RL_FLUX_read = []    


### Filling the lists with the data from the file

MODEL_key = 0 ### will be equal to 1 when in the subfolder of some model.
COSI_key = 0  ### will be equal to 1 when in the subfolder of some cosi.
for ilinha in range(0,len(g0linhas)):
    ### Check if entering a new model. If yes, read the model's parameters.
    if g0linhas[ilinha][0] == "MODEL" and MODEL_key == 0:
        current_MODEL = [g0linhas[ilinha][ii] for ii in range(1,5)]
        MODEL_key = 1
    ### Check if entering a SOURCE line. If yes, read the source parameters.
    if g0linhas[ilinha][0] == "SOURCE" and MODEL_key == 1:
        ### 'SOURCE_read' will receive a new element composed of 2 lists:
        ### 0: model parameters (not including cosi)
        ### 1: elements of 'SOURCE_read'
        current_SOURCE = [g0linhas[ilinha][ii] for ii in range(1,6)]
        SOURCE_read.append([current_MODEL,current_SOURCE])
    ### Check if entering the two TEMP_R and TEMP_T lines.
    ### If yes, read these parameters.
    if g0linhas[ilinha][0] == "TEMP_R" and MODEL_key == 1:
        ### 'TEMP_read' will receive a new element composed of 3 lists:
        ### 0: model parameters (not including cosi)
        ### 1: radial distances in the plane of the disk (R/Req)
        ### 2: temperatures of the disk [K]
        current_TEMP_R = [g0linhas[ilinha][ii] \
            for ii in range(1,len(g0linhas[ilinha]))]
        current_TEMP_T = [g0linhas[ilinha+1][ii] \
            for ii in range(1,len(g0linhas[ilinha+1]))]
        TEMP_read.append([current_MODEL,current_TEMP_R,current_TEMP_T])
    ### Check if entering a new cosi. If yes, read the cosi.
    if g0linhas[ilinha][0] == "COSI" and MODEL_key == 1 and COSI_key == 0:
        ### For a certain model, entering a new inclination (cosi)
        current_COSI = g0linhas[ilinha][1]
        COSI_key = 1
        
    
    def reading_procedure(lista,linename,Nelems):
        """
        
        """
        ### Check if entering a new 'linename'. 
        if g0linhas[ilinha][0] == linename and COSI_key == 1:
            ### 'lista' will receive a new element composed of 2 lists:
            ### 0: model parameters (including cosi)
            ### 1: elements of 'lista'
            auxi = [current_MODEL[ii] for ii in range(0,len(current_MODEL))]
            auxi.append(current_COSI)
            auxi2 = [g0linhas[ilinha][ii] for ii in range(1,Nelems)]
            lista.append([auxi,auxi2])
        return 

    reading_procedure(SNRATIOS_read,"SNRATIOS",len(g0linhas[ilinha]))
    ###
    reading_procedure(UBVRI_read,"UBVRI",1+5)
    reading_procedure(JHK_read,"JHK",1+3)
    reading_procedure(HALPHA_SOAR_read,"HALPHA_SOAR",1+1)
    reading_procedure(WISE_filters_read,"WISE_filters",1+4)
    reading_procedure(ALPHA_WISE_read,"ALPHA_WISE",1+3)
    reading_procedure(IRAC_filters_read,"IRAC_filters",1+4)
    ###
    reading_procedure(LINE_HALPHA_read,"LINE_HALPHA",1+5)
    reading_procedure(LINE_HBETA_read,"LINE_HBETA",1+5)
    reading_procedure(LINE_HGAMMA_read,"LINE_HGAMMA",1+5)    
    ###
    reading_procedure(LINE_BRALPHA_read,"LINE_BRALPHA",1+5)
    reading_procedure(LINE_BRGAMMA_read,"LINE_BRGAMMA",1+5)    
    ###
    reading_procedure(LINE_PFGAMMA_read,"LINE_PFGAMMA",1+5)    
    ###
    reading_procedure(LINE_HUMPHREY14_read,"LINE_HUMPHREY14",1+5)
    reading_procedure(LINE_HUMPHREY15_read,"LINE_HUMPHREY15",1+5)
    reading_procedure(LINE_HUMPHREY16_read,"LINE_HUMPHREY16",1+5)
    reading_procedure(LINE_HUMPHREY18_read,"LINE_HUMPHREY18",1+5)
    reading_procedure(LINE_HUMPHREY19_read,"LINE_HUMPHREY19",1+5)
    reading_procedure(LINE_HUMPHREY20_read,"LINE_HUMPHREY20",1+5)
    reading_procedure(LINE_HUMPHREY21_read,"LINE_HUMPHREY21",1+5)
    reading_procedure(LINE_HUMPHREY22_read,"LINE_HUMPHREY22",1+5)
    reading_procedure(LINE_HUMPHREY23_read,"LINE_HUMPHREY23",1+5)
    reading_procedure(LINE_HUMPHREY24_read,"LINE_HUMPHREY24",1+5)
    reading_procedure(LINE_HUMPHREY25_read,"LINE_HUMPHREY25",1+5)
    ###
    reading_procedure(BL_FLUX_read,"BL_FLUX",1+3)    
    reading_procedure(RL_FLUX_read,"RL_FLUX",1+3)    

    ### Check if finishing the cosi subfolder
    if g0linhas[ilinha][0] == "END_COSI" and COSI_key == 1:
        COSI_key = 0
    ### Check if finishing the model subfolder
    if g0linhas[ilinha][0] == "END_MODEL" and MODEL_key == 1:
        MODEL_key = 0





### The domain of the grids:
npar, sigpar, Mpar, obpar, cosipar = read_everything.domain_PLgrid()


### Now, creating the arrays for the observables of 4+1 model parameters
### The arrays will be functions of: (i_n, i_Sig, i_M, i_ob, i_cosi, #)

def attribution_procedure5(lista_read,Nelems):
    """
    This function creates the 6-array associated with the 'lista_read' 
    given. (5 of these dimensions are the 5 dimensions of the BeAtlas grid.)
    """
    
    array = np.zeros((len(npar),len(sigpar),len(Mpar),len(obpar),\
            len(cosipar),Nelems))
    array[:] = np.nan

    if len(lista_read) > 0:

        for i in range(0,len(lista_read)):
            idxnpar = npar.index(lista_read[i][0][0])
            idxsigpar = sigpar.index(lista_read[i][0][1])
            idxMpar = Mpar.index(lista_read[i][0][2])
            idxobpar = obpar.index(lista_read[i][0][3])
            idxcosipar = cosipar.index(lista_read[i][0][4])

            for j in range(0,Nelems):
                array[idxnpar,idxsigpar,idxMpar,idxobpar,idxcosipar,j] = \
                    float(lista_read[i][1][j])
                    
    return array
    
    
    

if len(SNRATIOS_read) > 0:
    SNRATIOS = attribution_procedure5(SNRATIOS_read,len(SNRATIOS_read[0][1]))
else:
    SNRATIOS = attribution_procedure5(SNRATIOS_read,0)

UBVRI = attribution_procedure5(UBVRI_read,5)
JHK = attribution_procedure5(JHK_read,3)
HALPHA_SOAR = attribution_procedure5(HALPHA_SOAR_read,1)
WISE = attribution_procedure5(WISE_filters_read,4)
ALPHA_WISE = attribution_procedure5(ALPHA_WISE_read,3)
IRAC = attribution_procedure5(IRAC_filters_read,4)
###
LINE_HALPHA = attribution_procedure5(LINE_HALPHA_read,5)
LINE_HBETA = attribution_procedure5(LINE_HBETA_read,5)
LINE_HGAMMA = attribution_procedure5(LINE_HGAMMA_read,5)
###
LINE_BRGAMMA = attribution_procedure5(LINE_BRGAMMA_read,5)
###
LINE_BRALPHA = attribution_procedure5(LINE_BRALPHA_read,5)
###
LINE_PFGAMMA = attribution_procedure5(LINE_PFGAMMA_read,5)
###
LINE_HUMPHREY14 = attribution_procedure5(LINE_HUMPHREY14_read,5)
LINE_HUMPHREY15 = attribution_procedure5(LINE_HUMPHREY15_read,5)
LINE_HUMPHREY16 = attribution_procedure5(LINE_HUMPHREY16_read,5)
LINE_HUMPHREY18 = attribution_procedure5(LINE_HUMPHREY18_read,5)
LINE_HUMPHREY19 = attribution_procedure5(LINE_HUMPHREY19_read,5)
LINE_HUMPHREY20 = attribution_procedure5(LINE_HUMPHREY20_read,5)
LINE_HUMPHREY21 = attribution_procedure5(LINE_HUMPHREY21_read,5)
LINE_HUMPHREY22 = attribution_procedure5(LINE_HUMPHREY22_read,5)
LINE_HUMPHREY23 = attribution_procedure5(LINE_HUMPHREY23_read,5)
LINE_HUMPHREY24 = attribution_procedure5(LINE_HUMPHREY24_read,5)
LINE_HUMPHREY25 = attribution_procedure5(LINE_HUMPHREY25_read,5)
###
BL_FLUX = attribution_procedure5(BL_FLUX_read,3)
RL_FLUX = attribution_procedure5(RL_FLUX_read,3)



### TODO: attribution procedure for the TEMP_T 
### (assuming that all TEMP_R are equal)
### DONE!
    

def attribution_procedure4(lista_read,Nelems):
    """
    This function creates the 5-array associated with the 'lista_read' 
    given. (4 of these dimensions are the 5-1 
    dimensions of the BeAtlas grid, minus cosi.)
    """
    
    array = np.zeros((len(npar),len(sigpar),len(Mpar),len(obpar),Nelems))
    array[:] = np.nan

    if len(lista_read) > 0:

        for i in range(0,len(lista_read)):
            idxnpar = npar.index(lista_read[i][0][0])
            idxsigpar = sigpar.index(lista_read[i][0][1])
            idxMpar = Mpar.index(lista_read[i][0][2])
            idxobpar = obpar.index(lista_read[i][0][3])

            for j in range(0,Nelems):
                array[idxnpar,idxsigpar,idxMpar,idxobpar,j] = np.nan
            for j in range(0,len(lista_read[i][1])):
                array[idxnpar,idxsigpar,idxMpar,idxobpar,j] = \
                    float(lista_read[i][1][j])
                    
    return array


### 
SOURCE = attribution_procedure4(SOURCE_read,5)



### TEMP_read.append([current_MODEL,current_TEMP_R,current_TEMP_T])

TEMP_R_read = [[elem[0],elem[1]] for elem in TEMP_read]
TEMP_T_read = [[elem[0],elem[2]] for elem in TEMP_read]

elemm = [np.nan, np.nan]
ielemm = 0
while np.isnan(float(elemm[0])) and np.isnan(float(elemm[1])) \
        and ielemm < len(TEMP_R_read):
    elemm = TEMP_R_read[ielemm][1]
    ielemm += 1
    
TEMP_R = np.array([float(x) for x in elemm])


Nelems = len(TEMP_R)
TEMP_T = attribution_procedure4(TEMP_T_read,Nelems)






### 
def fillingNaNs(folder_filledNaNs,nameval,axis,vals,tp,\
            allow_extrapolation,prints,overwrite = False):
    """
    This function applies the "powerful interpolation" in order to fill
    some or all of the NaNs in the 'vals' vector, but only if there isn't
    an already saved correspondent file in folder 'folder_filledNaNs'.
    
    The output of this function is a new 'vals' vector, with some of its 
    NaNs filled by the "powerful interpolation".
    """

    ### 
    list_filledNaNs = glob.glob(folder_filledNaNs + "*")
    
    ### 'found_fileNaN' will be True if there is a file with the same name
    ### as 'nameval' in the folder 'folder_filledNaNs'. If this isn't the case
    ### or if 'overwrite' is True, the filling the NaNs procedure will be 
    ### activated and, after that, the file with the calculated 'vals' will be 
    ### created. If, however, this is the case (else), the 'vals' will 
    ### be read from the external file.
    found_fileNaN = True in [folder_filledNaNs + nameval == \
                        x.replace(".dat","") for x in list_filledNaNs]
    if not found_fileNaN or overwrite:
        if prints != "no":
            print("FILLING THE NANS PROCEDURE (This may take some time!)")
        ### 
        vals = lrr.fill_NaNs_interp(axis,\
                vals,\
                tp,allow_extrapolation,prints)
        ### 
        f0 = open(folder_filledNaNs + nameval + ".dat","w")
        for elem in vals:
            f0.write(str(elem)+"\n")        
        f0.close()        
    ### 
    else:
        ### 
        f0 = open(folder_filledNaNs + nameval + ".dat","r")
        f0linhas = f0.readlines()
        f0.close()
        ### 
        vals = []
        for iline in range(0,len(f0linhas)):
            vals.append(float(f0linhas[iline]))

    return vals








#############################
### Central wavelength of each line [microns]
LINE_HALPHA_lbd = spt.hydrogenlinewl(3, 2)*1e6
LINE_HBETA_lbd = spt.hydrogenlinewl(4, 2)*1e6
LINE_HGAMMA_lbd = spt.hydrogenlinewl(5, 2)*1e6
LINE_BRGAMMA_lbd = spt.hydrogenlinewl(7, 4)*1e6
LINE_BRALPHA_lbd = spt.hydrogenlinewl(5, 4)*1e6
LINE_PFGAMMA_lbd = spt.hydrogenlinewl(8, 5)*1e6
LINE_HUMPHREY14_lbd = spt.hydrogenlinewl(14, 6)*1e6
LINE_HUMPHREY15_lbd = spt.hydrogenlinewl(15, 6)*1e6
LINE_HUMPHREY16_lbd = spt.hydrogenlinewl(16, 6)*1e6
LINE_HUMPHREY18_lbd = spt.hydrogenlinewl(18, 6)*1e6
LINE_HUMPHREY19_lbd = spt.hydrogenlinewl(19, 6)*1e6
LINE_HUMPHREY20_lbd = spt.hydrogenlinewl(20, 6)*1e6
LINE_HUMPHREY21_lbd = spt.hydrogenlinewl(21, 6)*1e6
LINE_HUMPHREY22_lbd = spt.hydrogenlinewl(22, 6)*1e6
LINE_HUMPHREY23_lbd = spt.hydrogenlinewl(23, 6)*1e6
LINE_HUMPHREY24_lbd = spt.hydrogenlinewl(24, 6)*1e6
LINE_HUMPHREY25_lbd = spt.hydrogenlinewl(25, 6)*1e6




##########################################################
### The list DATA_LBAND will contain important parameters derived from the 
### observables of our stars. Check the program 'read_data.py' to know the 
### contents of DATA_LBAND.
DATA_LBAND = read_data.returnDATA_LBAND()
### 
fluxhumphreys, EWhumphreys, GFWHMhumphreys, \
fluxBra, EWBra, GFWHMBra, \
fluxPfg, EWPfg, GFWHMPfg = read_data.LBAND_lines_extract(DATA_LBAND)


### If you want to make the tables of data for the paper, turn this on:
if 1==2:
    lixo = read_data.make_table_obs1(DATA_LBAND,"./tables/table_obs1.out")
    lixo = read_data.make_table_obs2(DATA_LBAND,"./tables/table_obs2.out")
    lixo = read_data.make_bigtables_obs(DATA_LBAND,"./tables/bigtables_obs.out")





##########################################################
### TODO Fredy's task: Generate prior distribution and save in external file.
### I will use it to plot qs in the observed diagrams.

### 
def newlog10abs(x,B):
    """
    This function is defined for all x real.
    It is a good approximation to log10(|x|), if |B*x| >> 1.
    
    Obs: This function explores the fact that 
    arcsinh(B*x) ~ sign(B*x)*A*ln[2*|B*x|], when |B*x| >> 1.
    """
    ### A*np.arcsinh(B*x)-np.sign(B*x)*A*np.log(2.*abs(B*x)) = 0
    ### A*np.arcsinh(B*x)-np.sign(B*x)*A*(np.log(2.*abs(B))+np.log(abs(x))) = 0
    ### np.sign(B*x)*np.arcsinh(B*x)-np.log(2.*abs(B))=np.log(abs(x))
    return np.arcsinh(abs(B*x))/np.log(10.)-np.log10(2.*abs(B))





### Se define la funcion necesaria para la Theta Big
def fBe(M,A):
   
    ell = 1.4*M**3.5
    log10ell = np.log10(1.4)+3.5*np.log10(M)
   
   
   
    A0 = -14.09101
    A1 = 8.71656
    A2 = -1.95159
    A3 = 0.11596
    A4 = 0.
    A5 = 0.
    A6 = 0.
   
    logf = A0+\
            A1*log10ell+\
            A2*log10ell**2.+\
            A3*log10ell**3.+\
            A4*log10ell**4.+\
            A5*log10ell**5.+\
            A6*log10ell**6.
   
    return A*np.exp(logf)



def find_area():

    Ar = 1.
    x = np.array([1.+0.01*float(i) for i in range(0,3500+1)])
    y = np.array([fBe(elem,Ar) for elem in x])

    ymin = 0.
    ymax = np.nanmax(y)
    xmin = np.nanmin(x)
    xmax = np.nanmax(x)

    icount = 0.
    incount = 0.
    for i in range(0,1000000):
        icount += 1.
        xr = np.random.uniform(xmin,xmax,None)
        yr = np.random.uniform(ymin,ymax,None)
        if yr <= fBe(xr,Ar):
            incount += 1.

    print(incount/icount*(xmax-xmin)*(ymax-ymin))

    return


if 1==2:

    A = 1.
    x = np.array([1.+0.01*float(i) for i in range(0,3500+1)])
    y = np.array([fBe(elem,A) for elem in x])


    plt.figure(figsize=(5.5,2.5))
    plt.plot(x,y)
    plt.xlabel("$M/M_\odot$")
    plt.ylabel("$f_\mathrm{Be}$")
    plt.xscale("log")
    #plt.yscale("log")
    plt.tight_layout()
    plt.show()







### En esta parte se define la ThetaBig, poniendo los intervalos para cada parametro
def thetabig(n,logSig,M,W,cosi):
   
    if 4.2 <= M <= 20. and \
            0. <= W <= 1. and \
            -np.inf <= logSig <= 0.6020599913279624 and \
            2. <= n <= 4.5 and \
            0. <= cosi <= 1.:
        return 1.
    else:
        return 0.




### Se define la funcion Prior
def lnprior(theta,other):
   


    ### Se definen los parametros de la Prior
    n = theta[0]
    logSig = theta[1]
    M = theta[2]
    W = np.sqrt(2.*(theta[3]-1.))
    cosi = theta[4]
   



    mean_W = other[0]
    std_W = other[1]
   
    thetab = thetabig(n,logSig,M,W,cosi)
   
    if thetab == 0.:
        return -np.inf
    else:
        fbe = fBe(M,1.)
        return -2.3*np.log(M) + np.log(fbe) \
                    - 0.5*(W-mean_W)*(W-mean_W)/std_W/std_W















##########################################################
##########################################################
### Now, comes the PART-1 of the analysis: making lots of plots!
### Some of these plots will be on the paper.

### Directory for the figures:
figures = "Figures/"


if 1==2:

    names = []
    alphaL = []
    erralphaL = []
    BL = []
    errBL = []
    MW3 = []
    errMW3 = []
    alphaW1W2 = []
    erralphaW1W2 = []
    alphaW2W3 = []
    erralphaW2W3 = []
    alphaW3W4 = []
    erralphaW3W4 = []

    for ifile in range(0,len(DATA_LBAND)):
        names.append(DATA_LBAND[ifile][0])
    
        alphaL.append(DATA_LBAND[ifile][5][4][0])
        erralphaL.append(DATA_LBAND[ifile][5][4][1]) 
        BL.append(DATA_LBAND[ifile][5][3][0])
        errBL.append(DATA_LBAND[ifile][5][3][1])

        MW3.append(DATA_LBAND[ifile][6][5][4])
        errMW3.append(DATA_LBAND[ifile][6][5][5])
        alphaW1W2.append(DATA_LBAND[ifile][6][2][0])
        erralphaW1W2.append(DATA_LBAND[ifile][6][2][1])
        alphaW2W3.append(DATA_LBAND[ifile][6][3][0])
        erralphaW2W3.append(DATA_LBAND[ifile][6][3][1])
        alphaW3W4.append(DATA_LBAND[ifile][6][4][0])
        erralphaW3W4.append(DATA_LBAND[ifile][6][4][1])


    plt.figure(figsize=(11,11))
    plt.subplot(221)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaL[i],BL[i],xerr=erralphaL[i],yerr=errMW3[i],color="red",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaL[i],BL[i]])
        plt.xlabel("$\\alpha_L$")
        plt.ylabel("$M_{B_L}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.subplot(222)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaW1W2[i],MW3[i],xerr=erralphaW1W2[i],yerr=errMW3[i],color="green",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaW1W2[i],MW3[i]])
        plt.xlabel("$\\alpha_{W1-W2}$")
        plt.ylabel("$M_{W3}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.subplot(223)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaW2W3[i],MW3[i],xerr=erralphaW2W3[i],yerr=errMW3[i],color="blue",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaW2W3[i],MW3[i]])
        plt.xlabel("$\\alpha_{W2-W3}$")
        plt.ylabel("$M_{W3}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.subplot(224)
    for i in range(0,len(DATA_LBAND)):
        plt.errorbar(alphaW3W4[i],MW3[i],xerr=erralphaW3W4[i],yerr=errMW3[i],color="purple",\
            linewidth=0.5)
        plt.annotate("HD "+names[i],[alphaW3W4[i],MW3[i]])
        plt.xlabel("$\\alpha_{W3-W4}$")
        plt.ylabel("$M_{W3}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
    plt.tight_layout()
    plt.show()





#############################
### TODO: plots of the SEDs and line profiles
if 1==2:

    import read_everything
    
    ### Reading fullsed, source and temperature files
    files_fullsed_new, files_source_new, files_temps_new, fullsed_contents, \
            fullsed_path, source_path, temps_path, dist_std = \
            read_everything.read_everything()




#############################
### Plotting observed Lenorzer Diagrams
if 1==2:

    ### Parameters for the double arcsinh scaling:
    up1 = 1.
    up2 = 5.  ### since most of the measured flux ratios are between 
                ### 0.1 and 1, the choice of up2 = 100 garantees the 
                ### nearly logarithmic behaviour of the scale for them.
    down1 = 0.2 * up1   ### This makes a "compression" of the negative axis.
    down2 = 5.

    names = []
    XL = []
    errXL = []
    YL = []
    errYL = []
    H14BL = []
    errH14BL = []
    for ifile in range(0,len(DATA_LBAND)):
        names.append(DATA_LBAND[ifile][0])
        XL.append(fluxhumphreys[ifile,14,0]/fluxPfg[ifile,0])
        YL.append(fluxhumphreys[ifile,14,0]/fluxBra[ifile,0])
        H14BL.append(fluxhumphreys[ifile,14,0]/DATA_LBAND[ifile][5][0][0]*\
                (DATA_LBAND[ifile][5][0][3]-DATA_LBAND[ifile][5][0][2]))
        
        errXL.append(abs(XL[-1])*np.sqrt(
                fluxhumphreys[ifile,14,1]**2./fluxhumphreys[ifile,14,0]**2.+\
                fluxPfg[ifile,1]**2./fluxPfg[ifile,0]**2.\
                ))
        errYL.append(abs(YL[-1])*np.sqrt(
                fluxhumphreys[ifile,14,1]**2./fluxhumphreys[ifile,14,0]**2.+\
                fluxBra[ifile,1]**2./fluxBra[ifile,0]**2.\
                ))
        errH14BL.append(abs(H14BL[-1])*np.sqrt(
                fluxhumphreys[ifile,14,1]**2./fluxhumphreys[ifile,14,0]**2.+\
                DATA_LBAND[ifile][5][0][1]**2./DATA_LBAND[ifile][5][0][0]**2.\
                ))
    

            
    ### Defining the labels of the axis
    axisvalsy=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.02,0.01,0.,\
                            -0.05,-0.5,-5.,-50.,500.])
    axisvalsx=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.01,0.,\
                            -0.5,-50.,500.])
    ### Obtaing the positions of the above defined labels of the axis
    transf_axisvalsy=np.array([lrr.scale_two_arcsinh(axisvalsy[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsy))])
    transf_axisvalsx=np.array([lrr.scale_two_arcsinh(axisvalsx[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsx))])

    ### Converting to the double arcsinh scale, for plotting:
    XLplot=np.array([lrr.scale_two_arcsinh(XL[i],up1,up2,down1,down2) \
        for i in range(0,len(XL))])
    YLplot=np.array([lrr.scale_two_arcsinh(YL[i],up1,up2,down1,down2) \
        for i in range(0,len(YL))])
    errXLplot=np.array([abs(lrr.scale_two_arcsinh(XL[i],up1,up2,down1,down2,\
        m="deriv"))*errXL[i] for i in range(0,len(errXL))])
    errYLplot=np.array([abs(lrr.scale_two_arcsinh(YL[i],up1,up2,down1,down2,\
        m="deriv"))*errYL[i] for i in range(0,len(errYL))])

    if 1==1:
        
        plt.figure(1,figsize=(11,11), dpi=100)

        plt.plot([0.,0.],[-1e32,1e32],linestyle=":",color="black",\
            linewidth=0.6)  ### Vertical dotted line
        plt.plot([-1e32,1e32],[0.,0.],linestyle=":",color="black",\
            linewidth=0.6)  ### Horizontal dotted line
    
        type1_x = -0.1
        type1_y = -0.2
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2)],\
                    [lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),1e32],linestyle=":",color="blue",\
            linewidth=0.5)  ### Vertical line delimiting "type 1 region"
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),1e32],[lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2)],linestyle=":",color="blue",\
            linewidth=0.5)  ### Horizontal line delimiting "type 1 region"
    
    
        for i in xrange(0,len(XLplot)):
            if H14BL[i] >= 0.:
                markk="o"
            else:
                markk="^"
            #if ~np.isnan(XL[i]) and ~np.isnan(YL[i]):
            plt.scatter([XLplot[i]],[YLplot[i]],marker=markk,\
                    s=1e4*(np.abs(H14BL[i])+np.abs(errH14BL[i]))/0.06e4,\
                    color="blue",facecolors="None")
            plt.scatter([XLplot[i]],[YLplot[i]],marker=markk,\
                    s=1e4*(np.abs(H14BL[i])-np.abs(errH14BL[i]))/0.06e4,\
                    color="red",facecolors="None")
            plt.errorbar([XLplot[i]],[YLplot[i]],xerr=errXLplot[i],\
                    yerr=errYLplot[i],color="black")
            plt.annotate("HD "+names[i],[XLplot[i],YLplot[i]])
            
    
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.01$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.003$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.001$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.001$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.01$")
        ### Add a legend
        plt.legend()

        plt.xscale('linear')
        plt.yscale('linear')
        plt.xlabel("$F(\mathrm{H}_{14})/F(\mathrm{Pf}_{\gamma})$")
        plt.ylabel("$F(\mathrm{H}_{14})/F(\mathrm{Br}_{\\alpha})$")
        plt.xticks(transf_axisvalsx,axisvalsx)
        plt.yticks(transf_axisvalsy,axisvalsy)
        plt.xlim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        plt.ylim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        
        plt.tight_layout()
        plt.savefig(figures+"LENORZERDATA.png")





#############################
### Plotting theoretical Lenorzer Diagrams
if 1==2:

    ### Parameters for the double arcsinh scaling:
    up1 = 1.
    up2 = 5.  ### since most of the measured flux ratios are between 
                ### 0.1 and 1, the choice of up2 = 100 garantees the 
                ### nearly logarithmic behaviour of the scale for them.
    down1 = 0.2 * up1   ### This makes a "compression" of the negative axis.
    down2 = 5.

    
    XL=[]
    YL=[]
    H14BL=[]
    figname=[]
    figtitle=[]
    annotate_vec=[]
    i_n = npar.index("4.5")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("04.20")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")
    
    ###
    #kinit = 1
    #colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    #for iplot1 in range(0,len(sigpar)):
    #    auxi_XL=[]
    #    auxi_YL=[]
    #    auxi_H14BL=[]
    #    auxi_annotate_vec=[]
    #    for iplot2 in range(0,len(cosipar)):
    #        auxi_XL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
    #            LINE_PFGAMMA[i_n,iplot1,i_M,i_ob,iplot2,0])
    #        auxi_YL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
    #            LINE_BRALPHA[i_n,iplot1,i_M,i_ob,iplot2,0])
    #        auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
    #            BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*\
    #                   (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
    #                   BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1])*1e4)
    #        auxi_annotate_vec.append("$\cos i$ = "+\
    #                str(round(abs(float(cosipar[iplot2])),2)))
    #    XL.append(auxi_XL)
    #    YL.append(auxi_YL)
    #    H14BL.append(auxi_H14BL)
    #    annotate_vec.append(auxi_annotate_vec)
    #    figname.append("n{0}_sig{1}_M{2}_ob{3}_cosi_X.png".format(\
    #        npar[i_n],sigpar[iplot1],Mpar[i_M],obpar[i_ob]))
    #    figtitle.append("$n="+npar[i_n]+"$, $\Sigma_0="+sigpar[iplot1]+\
    #        "\,\mathrm{g\,cm^{-2}}$")

    ###
    kinit = 0
    colorvec=["black","black","black","black","black","black","black",\
                    "black","black","black"]
    for iplot2 in range(0,len(cosipar)):
        auxi_XL=[]
        auxi_YL=[]
        auxi_H14BL=[]
        auxi_annotate_vec=[]
        for iplot1 in range(0,len(sigpar)):
            auxi_XL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                LINE_PFGAMMA[i_n,iplot1,i_M,i_ob,iplot2,0])
            auxi_YL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                LINE_BRALPHA[i_n,iplot1,i_M,i_ob,iplot2,0])
            auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*\
                        (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                        BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1])*1e4)
            auxi_annotate_vec.append("$\Sigma_0$ = "+sigpar[iplot1])
        XL.append(auxi_XL)
        YL.append(auxi_YL)
        H14BL.append(auxi_H14BL)
        annotate_vec.append(auxi_annotate_vec)
        figname.append("n{0}_sigX.XX_M{1}_ob{2}_cosi_{3}.png".format(\
            npar[i_n],Mpar[i_M],obpar[i_ob],str(round(abs(float(cosipar[iplot2])),2)) ))
        figtitle.append("$n="+npar[i_n]+"$, $\cos i = "+\
                    str(round(abs(float(cosipar[iplot2])),2))+"$")


    ### 
    XL=[np.array(XL[k]) for k in range(0,len(XL))]
    YL=[np.array(YL[k]) for k in range(0,len(XL))]
    H14BL=[np.array(H14BL[k]) for k in range(0,len(XL))]
        
    ### Defining the labels of the axis
    axisvalsy=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.02,0.01,0.,\
                            -0.05,-0.5,-5.,-50.,500.])
    axisvalsx=np.array([5.,2.,1.,0.5,0.2,0.1,0.05,0.01,0.,\
                            -0.5,-50.,500.])
    ### Obtaing the positions of the above defined labels of the axis
    transf_axisvalsy=np.array([lrr.scale_two_arcsinh(axisvalsy[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsy))])
    transf_axisvalsx=np.array([lrr.scale_two_arcsinh(axisvalsx[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsx))])

    ### Converting to the double arcsinh scale, for plotting:
    XLplot=[np.array([lrr.scale_two_arcsinh(XL[k][i],up1,up2,down1,down2) \
        for i in range(0,len(XL[k]))]) for k in range(0,len(XL))]
    YLplot=[np.array([lrr.scale_two_arcsinh(YL[k][i],up1,up2,down1,down2) \
        for i in range(0,len(YL[k]))]) for k in range(0,len(YL))]


    for k in range(kinit,len(XL)):
        
        plt.figure(k,figsize=(5.5, 5.5), dpi=100)

        plt.plot([0.,0.],[-1e32,1e32],linestyle=":",color="black",\
            linewidth=0.6)  ### Vertical dotted line
        plt.plot([-1e32,1e32],[0.,0.],linestyle=":",color="black",\
            linewidth=0.6)  ### Horizontal dotted line
    
        type1_x = -0.1
        type1_y = -0.2
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2)],\
                    [lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),1e32],linestyle=":",color="blue",\
            linewidth=0.5)  ### Vertical line delimiting "type 1 region"
        plt.plot([lrr.scale_two_arcsinh(10.**type1_x,\
                up1,up2,down1,down2),1e32],[lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(10.**type1_y,\
                up1,up2,down1,down2)],linestyle=":",color="blue",\
            linewidth=0.5)  ### Horizontal line delimiting "type 1 region"
    
    
        plt.plot(XLplot[k],YLplot[k],linewidth=0.3,color=colorvec[k])
        for i in xrange(0,len(XLplot[k])):
            if H14BL[k][i] >= 0.:
                markk="o"
            else:
                markk="^"
            plt.scatter([XLplot[k][i]],[YLplot[k][i]],marker=markk,\
                s=1e4*np.abs(H14BL[k][i])/0.06e4,\
                color=colorvec[k],facecolors="None")
                #alpha=0.5+0.5*float(i)/float(len(XLplot[k])-1))
                #color="black",facecolors="none")
        
        i_init = -1; key_i_init = 0
        i_final = len(XLplot[k]); key_i_final = 0
        while i_init < len(XLplot[k])-1 and key_i_init == 0:
            i_init += 1
            if (XLplot[k][i_init] is not None) and \
                        (YLplot[k][i_init] is not None):
                if (~np.isnan(XLplot[k][i_init])) and \
                        (~np.isnan(YLplot[k][i_init])):
                    key_i_init = 1
        while i_final > 0 and key_i_final == 0:
            i_final -= 1
            if (XLplot[k][i_final] is not None) and \
                        (YLplot[k][i_final] is not None):
                if (~np.isnan(XLplot[k][i_final])) and \
                        (~np.isnan(YLplot[k][i_final])):
                    key_i_final = 1
        
        if (XLplot[k][i_init] is not None) and \
                    (YLplot[k][i_init] is not None):
            if (~np.isnan(XLplot[k][i_init])) and \
                    (~np.isnan(YLplot[k][i_init])):
                plt.text(XLplot[k][i_init],YLplot[k][i_init], \
                        annotate_vec[k][i_init])
        if (XLplot[k][i_final] is not None) and \
                    (YLplot[k][i_final] is not None):
            if (~np.isnan(XLplot[k][i_final])) and \
                    (~np.isnan(YLplot[k][i_final])):
                plt.text(XLplot[k][i_final],YLplot[k][i_final], \
                        annotate_vec[k][i_final])
            
    
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.01$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.003$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.001$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.001$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.01$")
        ### Add a legend
        plt.legend()

        plt.title(figtitle[k])
        plt.xscale('linear')
        plt.yscale('linear')
        plt.xlabel("$F(\mathrm{H}_{14})/F(\mathrm{Pf}_{\gamma})$")
        plt.ylabel("$F(\mathrm{H}_{14})/F(\mathrm{Br}_{\\alpha})$")
        plt.xticks(transf_axisvalsx,axisvalsx)
        plt.yticks(transf_axisvalsy,axisvalsy)
        plt.xlim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        plt.ylim([lrr.scale_two_arcsinh(-80.,\
                up1,up2,down1,down2),lrr.scale_two_arcsinh(8.,\
                up1,up2,down1,down2)])
        
        plt.savefig(figures+"LENORZER_"+figname[k])







#############################
### Plotting Humphrey's diagrams
if 1==2:
    
    ### Parameters for the double arcsinh scaling:
    up1 = 1.
    up2 = 5.    ### since most of the measured flux ratios are between 
                ### 0.1 and 1, the choice of up2 = 100 garantees the 
                ### nearly logarithmic behaviour of the scale for them.
    down1 = 0.2 * up1   ### This makes a "compression" of the negative axis.
    down2 = up2
    
    H14H19=[]; EWL_H14=[]
    H15H19=[]; EWL_H15=[]
    H16H19=[]; EWL_H16=[]
    H18H19=[]; EWL_H18=[]
    H19H19=[]; EWL_H19=[]
    H20H19=[]; EWL_H20=[]
    H21H19=[]; EWL_H21=[]
    H22H19=[]; EWL_H22=[]
    H23H19=[]; EWL_H23=[]
    H24H19=[]; EWL_H24=[]
    H25H19=[]; EWL_H25=[]
    H14BL=[]
    figname=[]
    figtitle=[]
    annotate_vec=[]
    
    i_n = npar.index("4.5")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("04.20")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")


    ### 
    kinit = 1
    colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    for iplot1 in range(0,len(sigpar)):
        auxi_H14H19=[]; auxi_EWL_H14=[]
        auxi_H15H19=[]; auxi_EWL_H15=[]
        auxi_H16H19=[]; auxi_EWL_H16=[]
        auxi_H18H19=[]; auxi_EWL_H18=[]
        auxi_H19H19=[]; auxi_EWL_H19=[]
        auxi_H20H19=[]; auxi_EWL_H20=[]
        auxi_H21H19=[]; auxi_EWL_H21=[]
        auxi_H22H19=[]; auxi_EWL_H22=[]
        auxi_H23H19=[]; auxi_EWL_H23=[]
        auxi_H24H19=[]; auxi_EWL_H24=[]
        auxi_H25H19=[]; auxi_EWL_H25=[]
        auxi_H14BL=[]
        auxi_annotate_vec=[]
        for iplot2 in range(0,len(cosipar)):
            
            def making_fluxratio(auxilist,NUM,DEN):
                auxilist.append(\
                NUM[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                DEN[i_n,iplot1,i_M,i_ob,iplot2,0])
                return
            
            making_fluxratio(auxi_H14H19,LINE_HUMPHREY14,LINE_HUMPHREY19)
            making_fluxratio(auxi_H15H19,LINE_HUMPHREY15,LINE_HUMPHREY19)
            making_fluxratio(auxi_H16H19,LINE_HUMPHREY16,LINE_HUMPHREY19)
            making_fluxratio(auxi_H18H19,LINE_HUMPHREY18,LINE_HUMPHREY19)
            making_fluxratio(auxi_H19H19,LINE_HUMPHREY19,LINE_HUMPHREY19)
            making_fluxratio(auxi_H20H19,LINE_HUMPHREY20,LINE_HUMPHREY19)
            making_fluxratio(auxi_H21H19,LINE_HUMPHREY21,LINE_HUMPHREY19)
            making_fluxratio(auxi_H22H19,LINE_HUMPHREY22,LINE_HUMPHREY19)
            making_fluxratio(auxi_H23H19,LINE_HUMPHREY23,LINE_HUMPHREY19)
            making_fluxratio(auxi_H24H19,LINE_HUMPHREY24,LINE_HUMPHREY19)
            making_fluxratio(auxi_H25H19,LINE_HUMPHREY25,LINE_HUMPHREY19)

            auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                    BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*\
                    (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                    BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1])*1e4)

            def making_ew(auxilist,NUM,DEN):
                auxilist.append(\
                NUM[i_n,iplot1,i_M,i_ob,iplot2,1]/\
                DEN*1e-4)                
                return
            
            making_ew(auxi_EWL_H14,LINE_HUMPHREY14,LINE_HUMPHREY14_lbd)
            making_ew(auxi_EWL_H15,LINE_HUMPHREY15,LINE_HUMPHREY15_lbd)
            making_ew(auxi_EWL_H16,LINE_HUMPHREY16,LINE_HUMPHREY16_lbd)
            making_ew(auxi_EWL_H18,LINE_HUMPHREY18,LINE_HUMPHREY18_lbd)
            making_ew(auxi_EWL_H19,LINE_HUMPHREY19,LINE_HUMPHREY19_lbd)
            making_ew(auxi_EWL_H20,LINE_HUMPHREY20,LINE_HUMPHREY20_lbd)
            making_ew(auxi_EWL_H21,LINE_HUMPHREY21,LINE_HUMPHREY21_lbd)
            making_ew(auxi_EWL_H22,LINE_HUMPHREY22,LINE_HUMPHREY22_lbd)
            making_ew(auxi_EWL_H23,LINE_HUMPHREY23,LINE_HUMPHREY23_lbd)
            making_ew(auxi_EWL_H24,LINE_HUMPHREY24,LINE_HUMPHREY24_lbd)
            making_ew(auxi_EWL_H25,LINE_HUMPHREY25,LINE_HUMPHREY25_lbd)
                        
            auxi_annotate_vec.append("$\cos i$ = "+\
                    str(round(abs(float(cosipar[iplot2])),2)))
                    
        H14H19.append(auxi_H14H19); EWL_H14.append(auxi_EWL_H14)
        H15H19.append(auxi_H15H19); EWL_H15.append(auxi_EWL_H15)
        H16H19.append(auxi_H16H19); EWL_H16.append(auxi_EWL_H16)
        H18H19.append(auxi_H18H19); EWL_H18.append(auxi_EWL_H18)
        H19H19.append(auxi_H19H19); EWL_H19.append(auxi_EWL_H19)
        H20H19.append(auxi_H20H19); EWL_H20.append(auxi_EWL_H20)
        H21H19.append(auxi_H21H19); EWL_H21.append(auxi_EWL_H21)
        H22H19.append(auxi_H22H19); EWL_H22.append(auxi_EWL_H22)
        H23H19.append(auxi_H23H19); EWL_H23.append(auxi_EWL_H23)
        H24H19.append(auxi_H24H19); EWL_H24.append(auxi_EWL_H24)
        H25H19.append(auxi_H25H19); EWL_H25.append(auxi_EWL_H25)
        H14BL.append(auxi_H14BL)
        annotate_vec.append(auxi_annotate_vec)
        figname.append("n{0}_sig{1}_M{2}_ob{3}_cosi_X.png".format(\
            npar[i_n],sigpar[iplot1],Mpar[i_M],obpar[i_ob]))
        figtitle.append("$n="+npar[i_n]+"$, $\Sigma_0="+sigpar[iplot1]+\
            "\,\mathrm{g\,cm^{-2}}$")





    ### 
    H14H19=[np.array(H14H19[k]) for k in range(0,len(H14H19))]
    H15H19=[np.array(H15H19[k]) for k in range(0,len(H15H19))]
    H16H19=[np.array(H16H19[k]) for k in range(0,len(H16H19))]
    H18H19=[np.array(H18H19[k]) for k in range(0,len(H18H19))]
    H19H19=[np.array(H19H19[k]) for k in range(0,len(H19H19))]
    H20H19=[np.array(H20H19[k]) for k in range(0,len(H20H19))]
    H21H19=[np.array(H21H19[k]) for k in range(0,len(H21H19))]
    H22H19=[np.array(H22H19[k]) for k in range(0,len(H22H19))]
    H23H19=[np.array(H23H19[k]) for k in range(0,len(H23H19))]
    H24H19=[np.array(H24H19[k]) for k in range(0,len(H24H19))]
    H25H19=[np.array(H25H19[k]) for k in range(0,len(H25H19))]
    H14BL=[np.array(H14BL[k]) for k in range(0,len(H14BL))]
    EWL_H14=[np.array(EWL_H14[k]) for k in range(0,len(EWL_H14))]
    EWL_H15=[np.array(EWL_H15[k]) for k in range(0,len(EWL_H15))]
    EWL_H16=[np.array(EWL_H16[k]) for k in range(0,len(EWL_H16))]
    EWL_H18=[np.array(EWL_H18[k]) for k in range(0,len(EWL_H18))]
    EWL_H19=[np.array(EWL_H19[k]) for k in range(0,len(EWL_H19))]
    EWL_H20=[np.array(EWL_H20[k]) for k in range(0,len(EWL_H20))]
    EWL_H21=[np.array(EWL_H21[k]) for k in range(0,len(EWL_H21))]
    EWL_H22=[np.array(EWL_H22[k]) for k in range(0,len(EWL_H22))]
    EWL_H23=[np.array(EWL_H23[k]) for k in range(0,len(EWL_H23))]
    EWL_H24=[np.array(EWL_H24[k]) for k in range(0,len(EWL_H24))]
    EWL_H25=[np.array(EWL_H25[k]) for k in range(0,len(EWL_H25))]
        
    ### Defining the labels of the axis
    axisvalsy=np.array([10.,5.,3.,2.,1.,0.5,0.2,0.1,0.,\
                            -0.5,-5.])
    ### Obtaing the positions of the above defined labels of the axis
    transf_axisvalsy=np.array([lrr.scale_two_arcsinh(axisvalsy[i],\
            up1,up2,down1,down2) for i in xrange(0,len(axisvalsy))])

    for k in range(kinit,len(H14H19)):

        Dlamb = 0.03
        
        def making_lambdas(lbdcenter,array,Dlamb):
            return np.array([lbdcenter - \
                0.5*Dlamb + Dlamb*float(i)/float(len(array)-1) \
                for i in xrange(0,len(array))])
                
        H14lamb = making_lambdas(LINE_HUMPHREY14_lbd,H14H19[k],Dlamb)
        H15lamb = making_lambdas(LINE_HUMPHREY15_lbd,H15H19[k],Dlamb)
        H16lamb = making_lambdas(LINE_HUMPHREY16_lbd,H16H19[k],Dlamb)
        H18lamb = making_lambdas(LINE_HUMPHREY18_lbd,H18H19[k],Dlamb)
        H19lamb = making_lambdas(LINE_HUMPHREY19_lbd,H19H19[k],Dlamb)
        H20lamb = making_lambdas(LINE_HUMPHREY20_lbd,H20H19[k],Dlamb)
        H21lamb = making_lambdas(LINE_HUMPHREY21_lbd,H21H19[k],Dlamb)
        H22lamb = making_lambdas(LINE_HUMPHREY22_lbd,H22H19[k],Dlamb)
        H23lamb = making_lambdas(LINE_HUMPHREY23_lbd,H23H19[k],Dlamb)
        H24lamb = making_lambdas(LINE_HUMPHREY24_lbd,H24H19[k],Dlamb)
        H25lamb = making_lambdas(LINE_HUMPHREY25_lbd,H25H19[k],Dlamb)
        
        plt.figure(k,figsize=(11, 7), dpi=100)

        plt.subplot(211)
            
        ymax = 15
        horlines = np.array([float(-15+ii) for ii in range(0,2*ymax+2)])
        for elem in horlines:
            plt.plot([-1e32,1e32],
            [lrr.scale_two_arcsinh(elem,up1,up2,down1,down2),\
            lrr.scale_two_arcsinh(elem,up1,up2,down1,down2)],
            linestyle=":",color="black",\
                linewidth=0.6)  ### Horizontal dotted lines
        
        colorvec=["red","green","blue"]
        kcolor=0
        
        def plot_ratio_line(x,y):
            plt.plot(x,np.array([\
                lrr.scale_two_arcsinh(y[j],up1,up2,down1,down2) \
                for j in range(0,len(y))]),\
                linewidth=0.3,color=colorvec[kcolor%3])
            return
        
        plot_ratio_line(H14lamb,H14H19[k]); kcolor+=1
        plot_ratio_line(H15lamb,H15H19[k]); kcolor+=1
        plot_ratio_line(H16lamb,H16H19[k]); kcolor+=1
        plot_ratio_line(H18lamb,H18H19[k]); kcolor+=1
        plot_ratio_line(H19lamb,H19H19[k]); kcolor+=1
        plot_ratio_line(H20lamb,H20H19[k]); kcolor+=1
        plot_ratio_line(H21lamb,H21H19[k]); kcolor+=1
        plot_ratio_line(H22lamb,H22H19[k]); kcolor+=1
        plot_ratio_line(H23lamb,H23H19[k]); kcolor+=1
        plot_ratio_line(H24lamb,H24H19[k]); kcolor+=1
        plot_ratio_line(H25lamb,H25H19[k]); kcolor+=1
        
                
        colorvec=["red","green","blue"]
        kcolor=0
        
        def plot_ratio_scatter(x,y):
            for i in xrange(0,len(y)):
                if H14BL[k][i] >= 0.:
                    markk="o"
                else:
                    markk="^"
                plt.scatter([x[i]],\
                    [lrr.scale_two_arcsinh(y[i],up1,up2,down1,down2)],\
                    marker=markk,\
                    s=1e4*np.abs(H14BL[k][i])/0.06e4,\
                    color=colorvec[kcolor%3],facecolors="None")
            return
            
        plot_ratio_scatter(H14lamb,H14H19[k]); kcolor+=1
        plot_ratio_scatter(H15lamb,H15H19[k]); kcolor+=1
        plot_ratio_scatter(H16lamb,H16H19[k]); kcolor+=1
        plot_ratio_scatter(H18lamb,H18H19[k]); kcolor+=1
        plot_ratio_scatter(H19lamb,H19H19[k]); kcolor+=1
        plot_ratio_scatter(H20lamb,H20H19[k]); kcolor+=1
        plot_ratio_scatter(H21lamb,H21H19[k]); kcolor+=1
        plot_ratio_scatter(H22lamb,H22H19[k]); kcolor+=1
        plot_ratio_scatter(H23lamb,H23H19[k]); kcolor+=1
        plot_ratio_scatter(H24lamb,H24H19[k]); kcolor+=1
        plot_ratio_scatter(H25lamb,H25H19[k]); kcolor+=1
            
            
    
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.01$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.003$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.001$")
        plt.scatter([1e32], [1e32],marker="o",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = 0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.0003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.0003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.001,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.001$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.003,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.003$")
        plt.scatter([1e32], [1e32],marker="^",s=1e4*0.01,\
            color="black",facecolors="none", \
            label="$F(\mathrm{H}_{14})/B_L = -0.01$")
        ### Add a legend
        #plt.legend()

        plt.subplot(212)

        plt.plot([-1e32,1e32],[0.,0.],linestyle=":",color="black",\
            linewidth=0.6)  ### Horizontal dotted line
            
        colorvec=["red","green","blue"]
        kcolor=0

        def plot_ew_line(x,y):
            plt.plot(x,y*1e4,linewidth=0.3,color=colorvec[kcolor%3])
            return

        plot_ew_line(H14lamb,EWL_H14[k]); kcolor+=1
        plot_ew_line(H15lamb,EWL_H15[k]); kcolor+=1
        plot_ew_line(H16lamb,EWL_H16[k]); kcolor+=1
        plot_ew_line(H18lamb,EWL_H18[k]); kcolor+=1
        plot_ew_line(H19lamb,EWL_H19[k]); kcolor+=1
        plot_ew_line(H20lamb,EWL_H20[k]); kcolor+=1
        plot_ew_line(H21lamb,EWL_H21[k]); kcolor+=1
        plot_ew_line(H22lamb,EWL_H22[k]); kcolor+=1
        plot_ew_line(H23lamb,EWL_H23[k]); kcolor+=1
        plot_ew_line(H24lamb,EWL_H24[k]); kcolor+=1
        plot_ew_line(H25lamb,EWL_H25[k]); kcolor+=1
        
            
        colorvec=["red","green","blue"]
        kcolor=0
        
        def plot_ew_scatter(x,y):
            for i in xrange(0,len(y)):
                if H14BL[k][i] >= 0.:
                    markk="o"
                else:
                    markk="^"
                plt.scatter([x[i]],[y[i]*1e4],marker=markk,\
                    s=1e4*np.abs(H14BL[k][i])/0.06e4,\
                    color=colorvec[kcolor%3],facecolors="None")
            return        
        
        plot_ew_scatter(H14lamb,EWL_H14[k]); kcolor+=1
        plot_ew_scatter(H15lamb,EWL_H15[k]); kcolor+=1
        plot_ew_scatter(H16lamb,EWL_H16[k]); kcolor+=1
        plot_ew_scatter(H18lamb,EWL_H18[k]); kcolor+=1
        plot_ew_scatter(H19lamb,EWL_H19[k]); kcolor+=1
        plot_ew_scatter(H20lamb,EWL_H20[k]); kcolor+=1
        plot_ew_scatter(H21lamb,EWL_H21[k]); kcolor+=1
        plot_ew_scatter(H22lamb,EWL_H22[k]); kcolor+=1
        plot_ew_scatter(H23lamb,EWL_H23[k]); kcolor+=1
        plot_ew_scatter(H24lamb,EWL_H24[k]); kcolor+=1
        plot_ew_scatter(H25lamb,EWL_H25[k]); kcolor+=1
        



        plt.subplot(211)
        plt.title(figtitle[k])
        plt.xscale('linear')
        plt.yscale('linear')
        plt.yticks(transf_axisvalsy,axisvalsy)
        plt.ylabel("$F(\mathrm{H}_{n})/F(\mathrm{H}_{19})$")
        plt.xlabel("$\lambda\,[\mathrm{\mu m}]$")
        plt.xlim([3.4,4.1])
        plt.ylim([lrr.scale_two_arcsinh(-15.,up1,up2,down1,down2),\
            lrr.scale_two_arcsinh(15.,up1,up2,down1,down2)])

        plt.subplot(212)
        plt.xscale('linear')
        plt.yscale('linear')
        plt.ylabel("$EW/\lambda\,[\\times 10^{4}]$")
        plt.xlabel("$\lambda\,[\mathrm{\mu m}]$")
        plt.xlim([3.4,4.1])
        plt.ylim([2.5,-2.5])
        
        plt.savefig(figures+"HUMPHREYS_"+figname[k])




#############################
### Plotting Mennickent-based CMD
if 1==2:

    ###
    lamb1_BL=3.41 ; lamb2_BL=3.47
    lamb1_RL=3.93 ; lamb2_RL=4.00
    Nnpts=50
    xlp,ylp = lrr.VEGA_spct("spct1")
            
    llamb=np.array([lamb1_BL+(lamb2_BL-lamb1_BL)/\
        float(Nnpts-1)*float(i) for i in range(0,Nnpts)])*1e4
    dllamb=np.array([llamb[i+1]-llamb[i] for i in range(0,Nnpts-1)])
    ylpf=np.array([lrr.interpLinND([llamb[i]],[xlp],ylp) \
        for i in range(0,Nnpts)])
    B_Vega=lrr.integrate_trapezia(ylpf,dllamb)
    #print(B_Vega,B_Vega*0.5*(lamb1_BL+lamb2_BL)*1e-4/phc.c.cgs/phc.h.cgs)

    

    XL=[]
    YL=[]
    H14BL=[]
    figname=[]
    figtitle=[]
    annotate_vec=[]
    i_n = npar.index("3.0")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("14.60")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")


    ###
    kinit = 0
    colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    figname_now="n{0}_sigX.XX_M{1}_ob{2}_cosi_X.png".format(\
            npar[i_n],Mpar[i_M],obpar[i_ob])
    for iplot1 in range(0,len(sigpar)):
        auxi_XL=[]
        auxi_YL=[]
        auxi_H14BL=[]
        auxi_annotate_vec=[]
        for iplot2 in range(0,len(cosipar)):
            auxi_XL.append(1.-np.log10(
                (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]/
                (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]))/\
                (RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]/
                (RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2]-\
                RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]))
                )/np.log10(\
                (RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]+\
                RL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2])/\
                (BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,1]+\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,2])
                ))
            auxi_YL.append(-2.5*np.log10(
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                B_Vega))
            auxi_H14BL.append(LINE_HUMPHREY14[i_n,iplot1,i_M,i_ob,iplot2,0]/\
                BL_FLUX[i_n,iplot1,i_M,i_ob,iplot2,0]*(lamb2_BL-lamb1_BL)*1e4)
            auxi_annotate_vec.append("$\cos i$ = "+\
                    str(round(abs(float(cosipar[iplot2])),2)))
        XL.append(auxi_XL)
        YL.append(auxi_YL)
        H14BL.append(auxi_H14BL)
        annotate_vec.append(auxi_annotate_vec)
        figname.append("n{0}_sig{1}_M{2}_ob{3}_cosi_X.png".format(\
            npar[i_n],sigpar[iplot1],Mpar[i_M],obpar[i_ob]))
        figtitle.append("$n="+npar[i_n]+"$, $\Sigma_0="+sigpar[iplot1]+\
            "\,\mathrm{g\,cm^{-2}}$")



    ### 
    XL=[np.array(XL[k]) for k in range(0,len(XL))]
    YL=[np.array(YL[k]) for k in range(0,len(XL))]
    H14BL=[np.array(H14BL[k]) for k in range(0,len(XL))]

    plt.figure(0,figsize=(5.5, 5.5), dpi=100)

    for ifile in range(0,len(DATA_LBAND)):
        plt.errorbar([DATA_LBAND[ifile][5][4][0]],[DATA_LBAND[ifile][5][3][0]],\
                    xerr=DATA_LBAND[ifile][5][4][1],\
                    yerr=DATA_LBAND[ifile][5][3][1],color="gray",linewidth=0.3)
    for ifile in range(0,len(DATA_LBAND)):
        plt.text(DATA_LBAND[ifile][5][4][0],DATA_LBAND[ifile][5][3][0],\
                    DATA_LBAND[ifile][1], fontsize=8)


    for k in range(kinit,len(XL)):
    
        plt.plot(XL[k],YL[k],linewidth=0.3,color=colorvec[k])
        for i in xrange(0,len(XL[k])):
            if H14BL[k][i] >= 0.:
                markk="o"
            else:
                markk="^"
            plt.scatter([XL[k][i]],[YL[k][i]],marker=markk,\
                s=1e4*np.abs(H14BL[k][i])/(lamb2_BL-lamb1_BL)/1e4,\
                color=colorvec[k],facecolors="None")
        pass


    #plt.title(figtitle[k])
    plt.xscale('linear')
    plt.yscale('linear')
    plt.xlabel("$\\alpha_L$")
    plt.ylabel("$M_{B_L}\,[\mathrm{mag}]$")
    plt.xlim([-4.5,-0.5])
    plt.ylim([-0.5,-7.0])

    #plt.xlim([np.nanmin(alphaL)-0.1*(np.nanmax(alphaL)-np.nanmin(alphaL)),\
    #    np.nanmax(alphaL)+0.1*(np.nanmax(alphaL)-np.nanmin(alphaL))])
    #plt.ylim([np.nanmax(BL_Bvega)+0.1*(np.nanmax(BL_Bvega)-np.nanmin(BL_Bvega)),\
    #    np.nanmin(BL_Bvega)-0.1*(np.nanmax(BL_Bvega)-np.nanmin(BL_Bvega))])
        
    plt.tight_layout()
    #plt.show()
    plt.savefig(figures+"CMD_"+figname_now)








#############################
### Plotting magnitude diagrams for the work with Alejandro and K. Vieira
if 1==2:
    
    i_n = npar.index("3.5")
    i_sig = sigpar.index("1.65")
    i_M = Mpar.index("14.60")
    i_ob = obpar.index("1.40")
    i_cosi = cosipar.index("1.0")
    
    colorvec=[  "gray","black","brown","red","orange","green","blue","purple"]
    



    xmax = np.nanmax(UBVRI[:,:,:,:,:,1]-UBVRI[:,:,:,:,:,2])
    xmin = np.nanmin(UBVRI[:,:,:,:,:,1]-UBVRI[:,:,:,:,:,2])
    ymax = np.nanmax(UBVRI[:,:,:,:,:,2])
    ymin = np.nanmin(UBVRI[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = UBVRI[i_n,i_sig,i_M,i_ob,:,1]-UBVRI[i_n,i_sig,i_M,i_ob,:,2]
        #y = UBVRI[i_n,i_sig,i_M,i_ob,:,2]
        x = UBVRI[:,:,:,:,:,1]-UBVRI[:,:,:,:,:,2]
        y = UBVRI[:,:,:,:,:,2]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("B-V")
    plt.ylabel("V")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    
    xmax = np.nanmax(UBVRI[:,:,:,:,:,2]-UBVRI[:,:,:,:,:,4])
    xmin = np.nanmin(UBVRI[:,:,:,:,:,2]-UBVRI[:,:,:,:,:,4])
    ymax = np.nanmax(UBVRI[:,:,:,:,:,2])
    ymin = np.nanmin(UBVRI[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = UBVRI[i_n,i_sig,i_M,i_ob,:,2]-UBVRI[i_n,i_sig,i_M,i_ob,:,4]
        #y = UBVRI[i_n,i_sig,i_M,i_ob,:,2]
        x = UBVRI[:,:,:,:,:,2]-UBVRI[:,:,:,:,:,4]
        y = UBVRI[:,:,:,:,:,2]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("V-I")
    plt.ylabel("V")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()


    xmax = np.nanmax(JHK[:,:,:,:,:,0]-JHK[:,:,:,:,:,1])
    xmin = np.nanmin(JHK[:,:,:,:,:,0]-JHK[:,:,:,:,:,1])
    ymax = np.nanmax(JHK[:,:,:,:,:,1]-JHK[:,:,:,:,:,2])
    ymin = np.nanmin(JHK[:,:,:,:,:,1]-JHK[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-JHK[i_n,i_sig,i_M,i_ob,:,1]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,1]-JHK[i_n,i_sig,i_M,i_ob,:,2]
        x = JHK[:,:,:,:,:,0]-JHK[:,:,:,:,:,1]
        y = JHK[:,:,:,:,:,1]-JHK[:,:,:,:,:,2]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-H")
    plt.ylabel("H-K")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymin-0.1*(ymax-ymin),\
                ymax+0.1*(ymax-ymin)])
    plt.show()



    xmax0 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,0])
    xmax1 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,1])
    xmax2 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,2])
    xmax3 = np.nanmax(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,3])
    xmin0 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,0])
    xmin1 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,1])
    xmin2 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,2])
    xmin3 = np.nanmin(JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,3])
    xmax = np.nanmax([xmax0,xmax1,xmax2,xmax3])
    xmin = np.nanmax([xmin0,xmin1,xmin2,xmin3])
    ymax = np.nanmax(JHK[:,:,:,:,:,0])
    ymin = np.nanmin(JHK[:,:,:,:,:,2])
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,0]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,0]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[1]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,1]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,1]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[2]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,2]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,2]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[3]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()
    for i_sig in range(0,len(sigpar)):
        i = i_sig 
        #x = JHK[i_n,i_sig,i_M,i_ob,:,0]-IRAC[i_n,i_sig,i_M,i_ob,:,3]
        #y = JHK[i_n,i_sig,i_M,i_ob,:,0]
        x = JHK[:,:,:,:,:,0]-IRAC[:,:,:,:,:,3]
        y = JHK[:,:,:,:,:,0]
        plt.scatter(x,y,color = colorvec[i%len(colorvec)])
    plt.xlabel("J-[4]")
    plt.ylabel("J")
    plt.xlim([xmin-0.1*(xmax-xmin),\
                xmax+0.1*(xmax-xmin)])
    plt.ylim([ymax+0.1*(ymax-ymin),\
                ymin-0.1*(ymax-ymin)])
    plt.show()


    


    import sys; sys.exit()


if 1==2:
    
    def lnprobPriorStar(theta, uvlims, Z):
        """ Returns the prior probability function. """
        n=theta[0]
        Sig0=theta[1]
        M=theta[2]
        W=theta[3]
        cosi=theta[4]
        
        p = priorn(n,uvlims[0][0],uvlims[0][1])*\
            priorSig0(Sig0,uvlims[1][0],uvlims[1][1])*\
            priorM(M,uvlims[2][0],uvlims[2][1],Z)*\
            priorW(W,uvlims[3][0],uvlims[3][1])*\
            priorcosi(cosi,uvlims[4][0],uvlims[4][1])
        if p == 0.:
            return -np.inf
        else:
            return np.log(p)

    def priorn(n,nmin,nmax):
        """ Returns the *a priori* probability of a star with main sequence
        age Tau be a Be star. """
        #interval check
        if n < nmin or n > nmax:
            return 0.
    
        return 1.
    
    def priorSig0(Sig0,Sig0min,Sig0max):
        """ Returns the *a priori* probability of a star with main sequence
        age Tau be a Be star. """
        #interval check
        if Sig0 < Sig0min or Sig0 > Sig0max:
            return 0.

        return 1./Sig0


    def priorM(M,Mmin,Mmax, Z=0.007):
        """ Returns the *a priori* probability of a star with mass M be a Be star.
    
        Masses always in Solar units. """
        #interval check
        if M < Mmin or M > Mmax:
            return 0.

        p = M**(-2.3)*fM(M, Z)

        return p

    def fM(M, Z):
        """ Function of the Be phenomenon as function of mass """
        if Z >= 0.045:
            a = .0017; b = 2.342
        else:
            a = .0107; b = 1.871
        #
        if M >= (1./a)**(1./b):
            p = 1.
        else:
            p = a*M**b
        return p
 

    def priorW(W,Wmin,Wmax):
        """ Returns the *a priori* probability of a star with rotation rate W be a
        Be star. """
        #interval check
        if W < Wmin or W > Wmax:
            return 0.

        Wmean = .81
        sigW = .12

        p = np.exp(-(W-Wmean)**2./(2.*sigW**2.))

        return p


    def priorcosi(cosi,cosimin,cosimax):
        """ Returns the *a priori* probability of a star at inclination angle i 
        be a Be star. """
        #interval check
        if cosi < cosimin or cosi > cosimax:
            return 0.

        return 1.


    nwalkers = 250  ### 250
    nsampling = 100 ### 100
    nchain = nsampling + 2000    ### 2000
    ndim = 5

    Z = 0.002
    uvlims= [   [3.0,4.5],\
                [0.02,4.0],\
                [3.2,14.6],\
                [0.,1.],\
                [0.,1.]\
            ]


    ### Choose an initial set of positions for the walkers.
    ### (It is a list of ndim-dimensional lists.)
    p0 = [  [np.random.uniform(uvlims[0][0],uvlims[0][1]),\
            np.random.uniform(uvlims[1][0],uvlims[1][1]),\
            np.random.uniform(uvlims[2][0],uvlims[2][1]),\
            np.random.uniform(uvlims[3][0],uvlims[3][1]),\
            np.random.uniform(uvlims[4][0],uvlims[4][1])] 
                for i in xrange(nwalkers)]



    ### Initialize the sampler with the chosen specs.
    sampler = emcee.EnsembleSampler(nwalkers, ndim, lnprobPriorStar, \
        args=[uvlims,Z], a=2, threads=1)


    print("SAMPLING...")
    pos, prob, state = sampler.run_mcmc(p0, nchain)
    print("SAMPLING DONE.")

    ### Uncheck this to see the evolution of the probabilities 
    ### for 'measuring x alone'
    if 1==2:
        lnprobability=[]
        lnprobability.append(sampler.lnprobability)

        poslnprob=np.arange(1,len(lnprobability[0][0])+1)
        fig=plt.figure(figsize=(6,6))
        ax=plt.subplot(1,1,1)
        
        for i in xrange(0,len(lnprobability[0])):
            plt.plot(poslnprob,[np.arcsinh(lnprobability[0][i][j]) \
                for j in range(0,len(lnprobability[0][0]))], \
                color='black', linewidth=0.05, linestyle='-')
        plt.ylabel("$\\arcsinh(\\ln(\\mathrm{prob}))$")
        plt.xlabel("position in the chain")
        plt.show()


    walkerss = []
    for ii in range(0,nwalkers*nsampling):
        walkerss.append(sampler.flatchain[-1-ii])

    
    



    nparf = np.array([float(elem) for elem in npar])
    sigparf = np.array([float(elem) for elem in sigpar])
    Mparf = np.array([float(elem) for elem in Mpar])
    Wparf = np.array([np.sqrt(2.*float(elem)-2.) for elem in obpar])
    cosiparf = np.array([abs(float(elem)) for elem in cosipar])

    axis = [nparf,sigparf,Mparf,Wparf,cosiparf]


    print("INTERPOLATING...")
    ### Atributing values to every point in the grid.
    UBVRI1values=[]
    UBVRI2values=[]
    UBVRI3values=[]
    UBVRI4values=[]
    UBVRI5values=[]
    HALPHA_SOARvalues=[]
    JHK1values=[]
    JHK2values=[]
    JHK3values=[]
    IRAC1values=[]
    IRAC2values=[]
    IRAC3values=[]
    IRAC4values=[]
    for i in xrange(0,len(nparf)):
        for j in xrange(0,len(sigparf)):
            for k in xrange(0,len(Mparf)):
                for l in xrange(0,len(Wparf)):
                    for m in xrange(0,len(cosiparf)):
                        UBVRI1values.append(UBVRI[i,j,k,l,m,0])
                        UBVRI2values.append(UBVRI[i,j,k,l,m,1])
                        UBVRI3values.append(UBVRI[i,j,k,l,m,2])
                        UBVRI4values.append(UBVRI[i,j,k,l,m,3])
                        UBVRI5values.append(UBVRI[i,j,k,l,m,4])
                        HALPHA_SOARvalues.append(HALPHA_SOAR[i,j,k,l,m])
                        JHK1values.append(JHK[i,j,k,l,m,0])
                        JHK2values.append(JHK[i,j,k,l,m,1])
                        JHK3values.append(JHK[i,j,k,l,m,2])
                        IRAC1values.append(IRAC[i,j,k,l,m,0])
                        IRAC2values.append(IRAC[i,j,k,l,m,1])
                        IRAC3values.append(IRAC[i,j,k,l,m,2])
                        IRAC4values.append(IRAC[i,j,k,l,m,3])


    UBVRI1walkers = []
    UBVRI2walkers = []
    UBVRI3walkers = []
    UBVRI4walkers = []
    UBVRI5walkers = []
    HALPHA_SOARwalkers = []
    JHK1walkers = []
    JHK2walkers = []
    JHK3walkers = []
    IRAC1walkers = []
    IRAC2walkers = []
    IRAC3walkers = []
    IRAC4walkers = []
    print("INTERPOLATIONS FOR U FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI1walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI1values))
    print("INTERPOLATIONS FOR B FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI2walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI2values))
    print("INTERPOLATIONS FOR V FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI3walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI3values))
    print("INTERPOLATIONS FOR R FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI4walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI4values))
    print("INTERPOLATIONS FOR I FILTER...")
    for ii in range(0,len(walkerss)):
        UBVRI5walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,UBVRI5values))
    print("INTERPOLATIONS FOR SOAR'S HALPHA FILTER...")
    for ii in range(0,len(walkerss)):
        HALPHA_SOARwalkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,HALPHA_SOARvalues))
    print("INTERPOLATIONS FOR J FILTER...")
    for ii in range(0,len(walkerss)):
        JHK1walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,JHK1values))
    print("INTERPOLATIONS FOR H FILTER...")
    for ii in range(0,len(walkerss)):
        JHK2walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,JHK2values))
    print("INTERPOLATIONS FOR K FILTER...")
    for ii in range(0,len(walkerss)):
        JHK3walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,JHK3values))
    print("INTERPOLATIONS FOR IRAC 1 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC1walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC1values))
    print("INTERPOLATIONS FOR IRAC 2 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC2walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC2values))
    print("INTERPOLATIONS FOR IRAC 3 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC3walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC3values))
    print("INTERPOLATIONS FOR IRAC 4 FILTER...")
    for ii in range(0,len(walkerss)):
        IRAC4walkers.append(lrr.interpLinND(np.array(walkerss[ii]),axis,IRAC4values))
        
    print("INTERPOLATIONS DONE.")

    fileext = "KV_walkers.txt"
    f0 = open(fileext,"w")
    
    for ii in range(0,len(walkerss)):
        f0.write(   str(walkerss[ii][0])+str(" ")+\
                    str(walkerss[ii][1])+str(" ")+\
                    str(walkerss[ii][2])+str(" ")+\
                    str(walkerss[ii][3])+str(" ")+\
                    str(walkerss[ii][4])+str(" ")+\

                    str(UBVRI1walkers[ii])+str(" ")+\
                    str(UBVRI2walkers[ii])+str(" ")+\
                    str(UBVRI3walkers[ii])+str(" ")+\
                    str(UBVRI4walkers[ii])+str(" ")+\
                    str(UBVRI5walkers[ii])+str(" ")+\
                    str(JHK1walkers[ii])+str(" ")+\
                    str(JHK2walkers[ii])+str(" ")+\
                    str(JHK3walkers[ii])+str(" ")+\
                    str(IRAC1walkers[ii])+str(" ")+\
                    str(IRAC2walkers[ii])+str(" ")+\
                    str(IRAC3walkers[ii])+str(" ")+\
                    str(IRAC4walkers[ii])+str(" ")+\
                    "\n"
        )
    
    f0.close()



##########################################################
##########################################################
### Now, comes the part 2 of the analysis: MCMC bayesian inference for comparison 
### of models and observations.

### File containing the operations to be performed on the Be stars
operations_on_stars = "operations_on_stars.inp"





def inside_binflims(theta,binflims):
    """
    This function returns True if theta is inside the limits 
    defined by 'binflims' and False otherwise.
    """
    if binflims[0][0] <= theta[0] <= binflims[0][1] and \
            binflims[1][0] <= theta[1] <= binflims[1][1] and \
            binflims[2][0] <= theta[2] <= binflims[2][1] and \
            binflims[3][0] <= theta[3] <= binflims[3][1] and \
            binflims[4][0] <= theta[4] <= binflims[4][1]:
        return True
    else:
        return False


def get_instructions(operations_on_stars):
    """
    This function reads the instructions of operations to be applied
    on the Be stars from our database.
    """

    ### Reading the contents of the file containing all instructions
    f0 = open(operations_on_stars,"r")
    lines = f0.readlines()
    f0.close()

    ### 'instructions' is a list that will contain all the instructions
    ### to be performed on all stars that are in the instructions file and 
    ### in our database.
    instructions = []
    ### Getting 'HDnames'
    data_folder, HDnames, Starnames, SIMBAD_Spt, YYYYMMDD_LBAND = \
                    read_data.List_Stars("stars")
    ### Loop over every line of the instructions file
    starkey = 0
    for iline in range(0,len(lines)):
        thisline = lines[iline].split()
        if len(thisline) > 0:
            ### Entering the "STAR" subfolder
            if thisline[0] == "STAR" and len(thisline) == 2:
                hdname = thisline[1]
                if hdname in HDnames:
                    instructions.append([hdname,[]])
                    starkey = 1
                else:
                    print("There is no Be star called HD "+hdname+\
                            " in the database.")
            
            ### For this specific star, reads instructions for bayesian 
            ### inference
            if (thisline[0] == "BINF_ALPHAW3W4_W3" or \
                thisline[0] == "BINF_ALPHAL_BL" or \
                thisline[0] == "BINF_LENORZER" )\
                        and len(thisline) == 6 and starkey == 1:
                if thisline[1] == "YES":
                    instructions[-1][1].append([    thisline[0],
                                                    thisline[2],
                                                    thisline[3],
                                                    thisline[4],
                                                    thisline[5]
                                                ])
                                            
            ### Leaves the "STAR" subfolder
            if thisline[0] == "END_STAR" and starkey == 1:
                starkey = 0
        
    return instructions


######################

def BINF_ALPHAW3W4_W3_procedure(DATA_LBAND_now,\
        nwalkers, Nchain, folder_output, suffix,\
        binflims):
    """
    This function does bayesian inference using the observables
    alphaW3w4 and MW3 only. 
    It does it for a specific star in our database.
    It prints the results of emcee in an external file.
    """

    ### importing sys, for the printing of progress bar
    import sys
    
    ### Type of interpolation and "allowing extrapolation" for the 
    ### bayesian inference.
    tp = "linear"
    allow_extrapolation = "no"
    
    ###################
    ### Posterior for measuring alphaW3W4 and MW3:
    def lnposterior(theta, x, sigmax, interpars, binflims, other, Nchain):
        
        ### Printing the progress bar on the screen
        if 1==1:
            sys.stdout.write("\rSAMPLING: {:2.3%}".\
                        format(float(sampler.iteration+1)/float(Nchain))+"     ")
            sys.stdout.flush()
        
        ### If there are NaNs in the data, the probability is zero:
        if np.isnan(x[0]) or np.isnan(x[1]) or \
                np.isnan(sigmax[0]) or np.isnan(sigmax[1]):
            return -np.inf
        
        ### Imposing the walkers to be inside the hyperrectangle 
        ### defined by 'binflims':
        is_inside = inside_binflims(theta, binflims)
        if not is_inside:
            return -np.inf
            
        ### Calculating the prior
        lnpr=lnprior(theta, other)
        ### If the prior isn't zero, calculate the likelihood also.
        if np.isinf(-lnpr):
            return lnpr
        else:
            return lnpr+lnlikelihood(theta, x, sigmax, interpars)


    ### Likelihood function for alphaW3W4 and MW3
    def lnlikelihood(theta, x, sigmax, interpars):
        
        ### 
        values1 = interpars[0]
        values2 = interpars[1]
        axis = interpars[2]
        tp = interpars[3]
        allow_extrapolation = interpars[4]

        ### alphaW3W4
        xmod0 = lrr.interpLinND(theta,axis,values1,tp,allow_extrapolation)
        ### MW3
        if np.isnan(xmod0):
            xmod1 = np.nan
        else:
            xmod1 = lrr.interpLinND(theta,axis,values2,tp,allow_extrapolation)
    
    
        if (not np.isnan(xmod0)) and (not np.isnan(xmod1)):
            return -0.5*(
                        ((xmod0-x[0])/sigmax[0])*((xmod0-x[0])/sigmax[0])+\
                        ((xmod1-x[1])/sigmax[1])*((xmod1-x[1])/sigmax[1])\
                        )
        else:
            return -np.inf
    ###################
    
    
    

    ### The domain of the grids:
    npar, sigpar, Mpar, obpar, cosipar = read_everything.domain_PLgrid()
    ### Converting strings to float
    npar_vals = np.array([float(x) for x in npar])
    logsigpar_vals = np.array([newlog10abs(float(x),1e5) for x in sigpar])
    Mpar_vals = np.array([float(x) for x in Mpar])
    obpar_vals = np.array([float(x) for x in obpar])
    cosipar_vals = np.array([float(x) for x in cosipar])

    ### Defining the domain of the grid
    axis = [npar_vals,logsigpar_vals,Mpar_vals,obpar_vals,cosipar_vals]
    ndim = len(axis)

    ### Attributing values for every element of the grid
    vals_alphaW3W4 = []
    vals_MW3 = []
    i4 = obpar.index("1.40")
    for i1 in range(0,len(npar_vals)):
        for i2 in range(0,len(logsigpar_vals)):
            for i3 in range(0,len(Mpar_vals)):
                for i4_notused in range(0,len(obpar_vals)):
                    for i5 in range(0,len(cosipar_vals)):
                        vals_alphaW3W4.append(ALPHA_WISE[i1,i2,i3,i4,i5,2])
                        vals_MW3.append(WISE[i1,i2,i3,i4,i5,2])
    
    ### Turn this on to fill the NaNs in the values (probably due to 
    ### the fact that the grid was not entirely computed).
    if 1==1:
        ### folder for printing the results
        folder_filledNaNs = "./extrap01/"
        ### Below, "yes" means printing the progress of the 
        ### filling NaNs procedure
        prints = "yes"
        ### Allowing extrapolation for the filling the NaNs procedure
        allow_extrapolation_fill = "yes"
        ### filling the NaNs of alphaW3W4
        vals_alphaW3W4_name = "vals_alphaW3W4"
        vals_alphaW3W4 = fillingNaNs(folder_filledNaNs,\
                        vals_alphaW3W4_name,axis,\
                        vals_alphaW3W4,\
                        tp,allow_extrapolation_fill,prints,overwrite = False)
        ### filling the NaNs of MW3
        vals_MW3_name = "vals_MW3"
        vals_MW3 = fillingNaNs(folder_filledNaNs,\
                        vals_MW3_name,axis,\
                        vals_MW3,\
                        tp,allow_extrapolation_fill,prints,overwrite = False)
    
    ### Data on this specific star (to go to bayesian inference)
    obs_alpha34 = DATA_LBAND_now[6][4][0]
    sig_alpha34 = DATA_LBAND_now[6][4][1]
    obs_MW3 = DATA_LBAND_now[6][5][4]
    sig_MW3 = DATA_LBAND_now[6][5][5]
    x = [obs_alpha34,obs_MW3]
    sigmax = [sig_alpha34,sig_MW3]
    ###
    interpars = [vals_alphaW3W4, vals_MW3, axis, tp, allow_extrapolation]
    other = [0.81, 0.12]
    
    ### Choose an initial set of positions for the walkers.
    ### (It is a list of ndim-dimensional lists.)
    p0 = [  [
            np.random.uniform(binflims[0][0],binflims[0][1]),
            np.random.uniform(binflims[1][0],binflims[1][1]),
            np.random.uniform(binflims[2][0],binflims[2][1]),
            np.random.uniform(binflims[3][0],binflims[3][1]),
            np.random.uniform(binflims[4][0],binflims[4][1])
            ] for i in range(nwalkers)
        ]
    
    
    ### Initializing the sampler with the chosen specs.
    sampler = emcee.EnsembleSampler(nwalkers, ndim, lnposterior,\
            args=[x, sigmax, interpars, binflims, other, Nchain])
    ### Sampling...
    print("SAMPLING for observables alphaW3W4 and MW3 of HD "+\
            DATA_LBAND_now[0]+"...")
    pos, prob, state = sampler.run_mcmc(p0, Nchain)
    print("\rSAMPLING: DONE         ")
    
    ### Writing results of the bayesian inference an external file,
    ### for future analysis
    writeline = []
    ### Printing the mean acceptance fraction
    ### (This number should be between 0.25 and 0.5)
    writeline.append("MAF "+str(np.mean(sampler.acceptance_fraction))+"\n")
    ### Printing the walkers's position for every element of the chain:
    for ichain in range(0,len(sampler.chain[0])):
        for iwalker in range(0,len(sampler.chain)):
            writeline.append(\
                    str(sampler.lnprobability[iwalker][ichain])+" "+\
                    str(sampler.chain[iwalker][ichain][0])+" "+\
                    str(sampler.chain[iwalker][ichain][1])+" "+\
                    str(sampler.chain[iwalker][ichain][2])+" "+\
                    str(sampler.chain[iwalker][ichain][3])+" "+\
                    str(sampler.chain[iwalker][ichain][4])+"\n"\
                    )
    output_filename = folder_output+\
        "BINF_ALPHAW3W4_W3__"+DATA_LBAND_now[0]+"__"+suffix+".out"
    f1 = open(output_filename,"w")
    for iwrite in range(0,len(writeline)):
        f1.write(writeline[iwrite])
    f1.close()
    
    
    
    
    
    
    ### Turn this on to see the evolution of the probabilities 
    if 1==1:
        lnprobability = sampler.lnprobability

        poslnprob=np.arange(1,len(lnprobability[0])+1)
        fig=plt.figure(figsize=(6,6))
        ax=plt.subplot(1,1,1)
        
        for iwalker in range(0,len(lnprobability)):
            plt.plot(poslnprob,[np.arcsinh(lnprobability[iwalker][ichain]) \
                for ichain in range(0,len(lnprobability[0]))], \
                color='black', linewidth=0.05, linestyle='-')
        plt.ylabel("$\\arcsinh(\\ln(\\mathrm{prob}))$")
        plt.xlabel("position in the chain")
        fig.savefig("convergence_"+DATA_LBAND_now[0]+".png")
    
    ### Turn this on to make a corner plot of the results.
    if 1==1:
        if Nchain >= 1000:
            nburnin = 300
        if 0 <= Nchain < 1000:
            nburnin = int(Nchain*0.3)
        samples = sampler.chain[:, nburnin:, :].reshape((-1, ndim))
        fig = corner.corner(samples, \
        labels = ["$n$","$\log(\\Sigma\,[\mathrm{g\,cm^{-2}}])$",\
        "$M\,[M_\odot]$","$1+0.5W^2$","$\cos i$"], bins=60)
        fig.savefig("teste_"+DATA_LBAND_now[0]+".png")

    ### Turn this on to make a "CMD-WISE" plot of the results.
    if 1==2:
        if Nchain >= 1000:
            nburnin = 900
        if 0 <= Nchain < 1000:
            nburnin = int(Nchain*0.9)
        xx = []
        yy = []
        for ichain in range(nburnin,Nchain):
            for iwalker in range(0,len(sampler.chain)):
                point = [   sampler.chain[iwalker][ichain][0],\
                            sampler.chain[iwalker][ichain][1],\
                            sampler.chain[iwalker][ichain][2],\
                            sampler.chain[iwalker][ichain][3],\
                            sampler.chain[iwalker][ichain][4]\
                        ]
                xx.append(lrr.interpLinND(point,axis,vals_alphaW3W4,\
                        tp,allow_extrapolation))
                yy.append(lrr.interpLinND(point,axis,vals_MW3,\
                        tp,allow_extrapolation))

        fig=plt.figure(figsize=(6,6))
        ax=plt.subplot(1,1,1)
        plt.scatter(xx,yy,alpha=np.nanmax([1./len(xx),2e-3]))
        plt.errorbar(obs_alpha34,obs_MW3,xerr=sig_alpha34,yerr=sig_MW3,\
            color="black",linewidth=2.0)
        plt.xlabel("$\\alpha_{W3-W4}$")
        plt.ylabel("$M_{W3}\,\mathrm{[mag]}$")
        plt.xlim([-5.,1.6])
        plt.ylim([0.,-7.])
        fig.savefig("CMD_WISE_"+DATA_LBAND_now[0]+".png")
        
    
    return 


######################

def BINF_ALPHAL_BL_procedure(DATA_LBAND_now,\
        nwalkers, Nchain, folder_output, suffix,\
        binflims):
    """
    This function does bayesian inference using the observables
    alphaL and MBL only. 
    It does it for a specific star in our database.
    It prints the results of emcee in an external file.
    """
    pass
    ### TODO: Fredy continues here...
    
    return
    

######################



### Getting instructions of operations to be applied to the data on
### Be stars.
instructions = get_instructions(operations_on_stars)
### Reading the data on our Be stars
data_folder, HDnames, Starnames, SIMBAD_Spt, YYYYMMDD_LBAND = \
                read_data.List_Stars("stars")
DATA_LBAND = read_data.returnDATA_LBAND()
fluxhumphreys, EWhumphreys, GFWHMhumphreys, \
            fluxBra, EWBra, GFWHMBra, \
            fluxPfg, EWPfg, GFWHMPfg = read_data.LBAND_lines_extract(DATA_LBAND)

### Now, this is the part in which the instructions are executed.
for iinst in range(0,len(instructions)):
    intructs_now = [x for x in instructions[iinst]]
    istar = HDnames.index(intructs_now[0])
    
    ### Loop over the instructions for this specific Be star
    for iinow in range(0,len(intructs_now[1])):
        ### Instructions: bayesian inference with the observables
        ### alphaW3W4 and MW3.
        if intructs_now[1][iinow][0] == "BINF_ALPHAW3W4_W3":
            ### 
            ndim = 5 
            DATA_LBAND_now = [x for x in DATA_LBAND[istar]]
            nwalkers = int(intructs_now[1][iinow][1])*2*ndim
            Nchain = int(intructs_now[1][iinow][2])
            folder_output = intructs_now[1][iinow][3]
            suffix = intructs_now[1][iinow][4]
            ### Hyperrectangular limits for the bayesian inference.
            binflims = [
                    [3.0,4.5],
                    [newlog10abs(0.02,1e5),newlog10abs(4.00,1e5)],
                    [4.2,14.6],
                    [1.2,1.4],
                    [0.26,1.00]
                    ]
            ### 
            BINF_ALPHAW3W4_W3_procedure(DATA_LBAND_now,\
                    nwalkers, Nchain, folder_output, suffix,\
                    binflims)
        
        ### TODO: Fredy should complete this...
        if intructs_now[1][iinow][0] == "BINF_ALPHAL_BL":
            ### 
            ndim = 5
            DATA_LBAND_now = [x for x in DATA_LBAND[istar]]
            nwalkers = int(intructs_now[1][iinow][1])*2*ndim
            Nchain = int(intructs_now[1][iinow][2])
            folder_output = intructs_now[1][iinow][3]
            suffix = intructs_now[1][iinow][4]
            
            ### TODO (Fredy)
            ### Call procedure for bayesian inference



















##########################################################
##########################################################
### Now, comes the part 3 of the analysis: analysis of the results 
### of the operations performed on the stars.












